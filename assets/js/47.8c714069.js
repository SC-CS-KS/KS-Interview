(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{291:function(a,t,s){"use strict";s.r(t);var e=s(28),E=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"java-数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-数据结构"}},[a._v("#")]),a._v(" Java 数据结构")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#java-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"}},[a._v("Java 数据结构")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#collection-%E4%B8%8E-collections%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"}},[a._v("Collection 与 Collections的区别是什么？")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#map-set-list-queuestack%E7%89%B9%E7%82%B9%E5%8F%8A%E7%94%A8%E6%B3%95"}},[a._v("Map, Set, List, Queue、Stack特点及用法")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#arraylist-linkedlist-vector%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"}},[a._v("ArrayList, LinkedList, Vector的区别是什么？")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#treemap-linkedhashmap-hashmap%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"}},[a._v("TreeMap, LinkedHashMap, HashMap的区别是什么？")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"#hashmap-%E8%80%83%E5%AF%9F%E7%82%B9"}},[a._v("Hashmap 考察点")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E4%BD%BF%E7%94%A8hashmap%E4%BB%96%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"}},[a._v("什么时候会使用HashMap？他有什么特点？")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#hashmap-%E5%9C%A8put%E5%92%8Cget%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"}},[a._v("HashMap 在put和get的时候是怎么工作的？")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#equals%E5%92%8Chashcode%E7%9A%84%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"}},[a._v("equals()和hashCode()的都有什么作用？")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#hashmap%E7%9A%84key%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E8%88%AC%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E5%A4%9A%E8%83%BD%E7%94%A8%E5%85%B6%E4%BB%96%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%90%97%E4%B8%BA%E4%BB%80%E4%B9%88"}},[a._v("HashMap的key为什么一般用字符串比较多，能用其他对象，或者自定义的对象吗？为什么？")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%88%9A%E6%89%8D%E6%8F%90%E5%88%B0hashmap%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%A0%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%97%AE%E9%A2%98"}},[a._v("刚才提到HashMap不是线程安全的，你怎么理解线程安全。原理是什么？ 几种方式避免线程安全的问题。")])]),a._v(" "),s("li",[s("a",{attrs:{href:"#%E5%A6%82%E6%9E%9Chashmap%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90load-factor%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%B9%E9%87%8F%E6%80%8E%E4%B9%88%E5%8A%9E"}},[a._v("如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？")])])])]),a._v(" "),s("li",[s("a",{attrs:{href:"#concurrenthashmap-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"}},[a._v("ConcurrentHashMap 的实现原理?")])])])])]),a._v(" "),s("h2",{attrs:{id:"collection-与-collections的区别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#collection-与-collections的区别是什么？"}},[a._v("#")]),a._v(" Collection 与 Collections的区别是什么？")]),a._v(" "),s("p",[a._v("Collection 是 Java 集合框架中的基本接口。\nCollections 是 Java 集合框架提供的一个工具类，其中包含了大量用于操作或返回集合的静态方法。")]),a._v(" "),s("h2",{attrs:{id:"map-set-list-queue、stack特点及用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-set-list-queue、stack特点及用法"}},[a._v("#")]),a._v(" Map, Set, List, Queue、Stack特点及用法")]),a._v(" "),s("ul",[s("li",[a._v("Map")])]),a._v(" "),s("p",[a._v("存储键值对的数据类型都实现了这个接口，表示“映射表”。\n支持的两个核心操作是get(Object key)以及put(K key, V value)")]),a._v(" "),s("ul",[s("li",[a._v("Set")])]),a._v(" "),s("p",[a._v("实现了这个接口的集合类型中不允许存在重复的元素，代表数学意义上的“集合”\n它所支持的核心操作有add(E e), remove(Object o), contains(Object o)")]),a._v(" "),s("ul",[s("li",[a._v("List")])]),a._v(" "),s("p",[a._v("集合框架中的列表类型都实现了这个接口，表示一种有序序列。\n支持get(int index), add(E e)等操作。")]),a._v(" "),s("ul",[s("li",[a._v("Queue")])]),a._v(" "),s("p",[a._v("集合框架中的队列接口，代表了“先进先出”队列"),s("br"),a._v("\n支持add(E element),remove()等操作")]),a._v(" "),s("ul",[s("li",[a._v("Stack")])]),a._v(" "),s("p",[a._v("表示堆栈的数据类型，堆栈是一种“后进先出”的数据结构。\n支持push(E item), pop()等操作。")]),a._v(" "),s("h2",{attrs:{id:"arraylist-linkedlist-vector的区别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arraylist-linkedlist-vector的区别是什么？"}},[a._v("#")]),a._v(" ArrayList, LinkedList, Vector的区别是什么？")]),a._v(" "),s("p",[a._v("ArrayList: 内部采用数组存储元素，支持高效随机访问，支持动态调整大小\nLinkedList: 内部采用链表来存储元素，支持快速插入/删除元素，但不支持高效地随机访问\nVector: 可以看作线程安全版的ArrayList")]),a._v(" "),s("h2",{attrs:{id:"treemap-linkedhashmap-hashmap的区别是什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#treemap-linkedhashmap-hashmap的区别是什么？"}},[a._v("#")]),a._v(" TreeMap, LinkedHashMap, HashMap的区别是什么？")]),a._v(" "),s("ul",[s("li",[a._v("HashMap")])]),a._v(" "),s("p",[a._v("底层实现是散列表，因此它内部存储的元素是无序的。")]),a._v(" "),s("ul",[s("li",[a._v("TreeMap")])]),a._v(" "),s("p",[a._v("的底层实现是红黑树，所以它内部的元素的有序的，"),s("br"),a._v("\n排序的依据是自然序或者是创建TreeMap时所提供的比较器（Comparator）对象。")]),a._v(" "),s("ul",[s("li",[a._v("LinkedHashMap")])]),a._v(" "),s("p",[a._v("可以看作能够记住插入元素的顺序的HashMap。")]),a._v(" "),s("h3",{attrs:{id:"hashmap-考察点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-考察点"}},[a._v("#")]),a._v(" Hashmap 考察点")]),a._v(" "),s("p",[a._v("HashMap的面试问题能够考察面试者的线程问题、Java内存模型问题、\n线程可见与不可变问题、Hash计算问题、链表结构问题、二进制的&、|、<<、>>等问题。")]),a._v(" "),s("h3",{attrs:{id:"什么时候会使用hashmap？他有什么特点？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会使用hashmap？他有什么特点？"}},[a._v("#")]),a._v(" 什么时候会使用HashMap？他有什么特点？")]),a._v(" "),s("p",[a._v("是基于Map接口的实现，存储键值对时。"),s("br"),a._v("\n它可以接收null的键值，是非同步的。"),s("br"),a._v("\nHashMap存储着Entry(hash, key, value, next)对象。")]),a._v(" "),s("h3",{attrs:{id:"hashmap-在put和get的时候是怎么工作的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap-在put和get的时候是怎么工作的？"}},[a._v("#")]),a._v(" HashMap 在put和get的时候是怎么工作的？")]),a._v(" "),s("h3",{attrs:{id:"equals-和hashcode-的都有什么作用？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals-和hashcode-的都有什么作用？"}},[a._v("#")]),a._v(" equals()和hashCode()的都有什么作用？")]),a._v(" "),s("p",[a._v("通过对key的hashCode()进行hashing，并计算下标( n-1 & hash)，从而获得buckets的位置\n如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点")]),a._v(" "),s("h3",{attrs:{id:"hashmap的key为什么一般用字符串比较多，能用其他对象，或者自定义的对象吗？为什么？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashmap的key为什么一般用字符串比较多，能用其他对象，或者自定义的对象吗？为什么？"}},[a._v("#")]),a._v(" HashMap的key为什么一般用字符串比较多，能用其他对象，或者自定义的对象吗？为什么？")]),a._v(" "),s("h3",{attrs:{id:"刚才提到hashmap不是线程安全的，你怎么理解线程安全。原理是什么？-几种方式避免线程安全的问题。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#刚才提到hashmap不是线程安全的，你怎么理解线程安全。原理是什么？-几种方式避免线程安全的问题。"}},[a._v("#")]),a._v(" 刚才提到HashMap不是线程安全的，你怎么理解线程安全。原理是什么？ 几种方式避免线程安全的问题。")]),a._v(" "),s("h3",{attrs:{id:"如果hashmap的大小超过了负载因子-load-factor-定义的容量，怎么办？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如果hashmap的大小超过了负载因子-load-factor-定义的容量，怎么办？"}},[a._v("#")]),a._v(" 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？")]),a._v(" "),s("p",[a._v("如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。")]),a._v(" "),s("h2",{attrs:{id:"concurrenthashmap-的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap-的实现原理"}},[a._v("#")]),a._v(" ConcurrentHashMap 的实现原理?")]),a._v(" "),s("p",[a._v("特点是读取数据时无需加锁，写数据时可以保证加锁粒度尽可能的小。\n采用“分段存储”，只需对要进行写操作的数据所在的“段”进行加锁。")])])}),[],!1,null,null,null);t.default=E.exports}}]);