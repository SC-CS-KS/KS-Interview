(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{256:function(v,_,e){"use strict";e.r(_);var s=e(28),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"分布式架构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式架构"}},[v._v("#")]),v._v(" 分布式架构")]),v._v(" "),e("h2",{attrs:{id:"为什么要进行系统拆分？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要进行系统拆分？"}},[v._v("#")]),v._v(" 为什么要进行系统拆分？")]),v._v(" "),e("p",[v._v("业务发展到一定量级，达到单体系统负载极限，无法再承载业务的进一步发展。"),e("br"),v._v("\n通过分而治之的方式，将系统拆分为子系统，进而通过扩展的方式不断适应业务的发展。")]),v._v(" "),e("p",[v._v("具体来讲，以下因素是考虑系统拆分的原因：")]),v._v(" "),e("ol",[e("li",[v._v("获得更高的系统整体性能；")]),v._v(" "),e("li",[v._v("使得系统可维护性、可扩展性增强；")]),v._v(" "),e("li",[v._v("增加代码的可维护性，减少代码冲突；")]),v._v(" "),e("li",[v._v("增加子系统的边界，保持领域内问题可控。")])]),v._v(" "),e("h2",{attrs:{id:"如何进行系统拆分？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何进行系统拆分？"}},[v._v("#")]),v._v(" 如何进行系统拆分？")]),v._v(" "),e("ol",[e("li",[v._v("考虑组织架构（康威定理）；")]),v._v(" "),e("li",[v._v("考虑领域划分；")]),v._v(" "),e("li",[v._v("考虑系统内聚与解耦；")]),v._v(" "),e("li",[v._v("考虑系统的分层；")]),v._v(" "),e("li",[v._v("考虑模块的代码量。")])]),v._v(" "),e("h2",{attrs:{id:"分布式服务接口的幂等性如何设计（比如不能重复扣款）？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式服务接口的幂等性如何设计（比如不能重复扣款）？"}},[v._v("#")]),v._v(" 分布式服务接口的幂等性如何设计（比如不能重复扣款）？")]),v._v(" "),e("ul",[e("li",[v._v("保证幂等性主要是三点：")])]),v._v(" "),e("ol",[e("li",[v._v("对于每个请求必须有一个唯一的标识；")]),v._v(" "),e("li",[v._v("每次处理完请求之后，必须有一个记录标识这个请求处理过了；")]),v._v(" "),e("li",[v._v("每次接收请求需要进行判断，判断之前是否处理过。")])]),v._v(" "),e("p",[v._v("需要结合业务场景解决。"),e("br"),v._v("\n比如利用 Redis，用 orderId 作为唯一键，只有成功插入这个支付流水，才可以执行实际的支付扣款。")]),v._v(" "),e("h2",{attrs:{id:"分布式服务接口请求的顺序性如何保证？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式服务接口请求的顺序性如何保证？"}},[v._v("#")]),v._v(" 分布式服务接口请求的顺序性如何保证？")]),v._v(" "),e("p",[v._v("一旦引入顺序性保障，比如使用分布式锁，会导致系统复杂度上升，而且会带来效率低下，热点数据压力过大等问题。"),e("br"),v._v("\n所以要尽量避免这类需求。")]),v._v(" "),e("p",[v._v("一般通过队列来保证。")]),v._v(" "),e("h2",{attrs:{id:"分布式锁的实现方案？哪种效率比较高？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的实现方案？哪种效率比较高？"}},[v._v("#")]),v._v(" 分布式锁的实现方案？哪种效率比较高？")]),v._v(" "),e("p",[v._v("分布式锁有 3 个重要的考量点："),e("br"),v._v("\n互斥（只能有一个客户端获取锁）"),e("br"),v._v("\n不能死锁"),e("br"),v._v("\n容错（只要大部分 Redis 节点创建了这把锁就可以）")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Redis")])]),v._v(" "),e("li",[e("ul",[e("li",[v._v("SET key value [EX seconds] [PX milliseconds] NX 创建一个 key")])])]),v._v(" "),e("li",[e("ul",[e("li",[v._v("RedLock 算法")])])]),v._v(" "),e("li",[e("p",[v._v("Zookeeper")])])]),v._v(" "),e("p",[v._v("某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；"),e("br"),v._v("\n这个时候别的客户端来创建锁会失败，只能注册个监听器监听这个锁。"),e("br"),v._v("\n释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。")]),v._v(" "),e("ul",[e("li",[e("ul",[e("li",[v._v("采用另一种方式，创建临时顺序节点：")])])])]),v._v(" "),e("p",[v._v("如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；"),e("br"),v._v("\n后面的每个人都会去监听排在自己前面的那个人创建的 node 上，"),e("br"),v._v("\n一旦某个人释放了锁，排在自己后面的人就会被 ZooKeeper 给通知，"),e("br"),v._v("\n一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。")]),v._v(" "),e("p",[v._v("比较：")]),v._v(" "),e("p",[v._v("redis 分布式锁，需要自己不断去尝试获取锁，比较消耗性能。\nzk 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。")]),v._v(" "),e("p",[v._v("如果是 Redis 获取锁的那个客户端 出现 bug 挂了，那么只能等待超时时间之后才能释放锁；"),e("br"),v._v("\n而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。")]),v._v(" "),e("h2",{attrs:{id:"分布式事务了解吗？你们如何解决分布式事务问题的？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务了解吗？你们如何解决分布式事务问题的？"}},[v._v("#")]),v._v(" 分布式事务了解吗？你们如何解决分布式事务问题的？")]),v._v(" "),e("h2",{attrs:{id:"分布式事务的实现方案？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务的实现方案？"}},[v._v("#")]),v._v(" 分布式事务的实现方案？")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("两阶段提交方案/XA方案")])]),v._v(" "),e("li",[e("p",[v._v("TCC 方案"),e("br"),v._v("\nTCC 的全称是： Try 、 Confirm 、 Cancel 。")])]),v._v(" "),e("li",[e("p",[v._v("本地消息表")])]),v._v(" "),e("li",[e("p",[v._v("可靠消息最终一致性方案")])]),v._v(" "),e("li",[e("p",[v._v("最大努力通知方案")])])]),v._v(" "),e("h2",{attrs:{id:"tcc-如果出现网络连不通怎么办？xa-的一致性如何保证？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcc-如果出现网络连不通怎么办？xa-的一致性如何保证？"}},[v._v("#")]),v._v(" TCC 如果出现网络连不通怎么办？XA 的一致性如何保证？")]),v._v(" "),e("h2",{attrs:{id:"集群部署时的分布式-session-如何实现？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#集群部署时的分布式-session-如何实现？"}},[v._v("#")]),v._v(" 集群部署时的分布式 Session 如何实现？")]),v._v(" "),e("ul",[e("li",[v._v("完全不用 Session")])]),v._v(" "),e("p",[v._v("使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。")]),v._v(" "),e("ul",[e("li",[v._v("Tomcat + Redis")])]),v._v(" "),e("p",[v._v("基于 Tomcat 原生的 Session 支持即可，然后就是用一个叫做 Tomcat  RedisSessionManager 的东西，"),e("br"),v._v("\n让所有我们部署的 Tomcat 都将 Session 数据存储到 Redis 即可。")]),v._v(" "),e("ul",[e("li",[v._v("Spring Session + Redis")])]),v._v(" "),e("p",[v._v("给 Spring Session 配置基于 Redis 来存储 Session 数据，"),e("br"),v._v("\n然后配置了一个 Spring Session 的过滤器，这样的话，Session 相关操作都会交给 Spring Session 来管了。"),e("br"),v._v("\n接着在代码中，就用原生的 Session 操作，就是直接基于 Spring Session 从 Redis 中获取数据了。")]),v._v(" "),e("h2",{attrs:{id:"zookeeper-的使用场景？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper-的使用场景？"}},[v._v("#")]),v._v(" Zookeeper 的使用场景？")]),v._v(" "),e("ul",[e("li",[v._v("分布式协调")])]),v._v(" "),e("p",[v._v("如 A 系统发送个请求到 mq，然后 B 系统消息消费之后处理了。那 A 系统如何知道 B 系统的处理结果？")]),v._v(" "),e("p",[v._v("A 系统发送请求之后可以在 zookeeper 上对某个节点的值注册个监听器，"),e("br"),v._v("\n一旦 B 系统处理完了就修改 zookeeper 那个节点的值，A 系统立马就可以收到通知，完美解决。")]),v._v(" "),e("ul",[e("li",[v._v("分布式锁")])]),v._v(" "),e("p",[v._v("一个机器接收到了请求之后先获取 zookeeper 上的一把分布式锁，就是可以去创建一个 znode，接着执行操作；"),e("br"),v._v("\n然后另外一个机器也尝试去创建那个 znode，结果发现自己创建不了，"),e("br"),v._v("\n因为被别人创建了，那只能等着，等第一个机器执行完了自己再执行。")]),v._v(" "),e("ul",[e("li",[v._v("元数据/配置信息管理")])]),v._v(" "),e("p",[v._v("zookeeper 可以用作很多系统的配置信息的管理，"),e("br"),v._v("\n比如 kafka、storm 等等很多分布式系统都会选用 zookeeper 来做一些元数据、配置信息的管理。")]),v._v(" "),e("ul",[e("li",[v._v("HA高可用性")])]),v._v(" "),e("p",[v._v("hadoop、hdfs、yarn 等很多大数据系统，都选择基于 zookeeper 来开发 HA 高可用机制，"),e("br"),v._v("\n就是一个重要进程一般会做主备两个，主进程挂了立马通过 zookeeper 感知到切换到备用进程。")])])}),[],!1,null,null,null);_.default=r.exports}}]);