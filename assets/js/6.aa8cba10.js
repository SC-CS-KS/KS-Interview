(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{251:function(t,a,s){"use strict";s.r(a);var l=s(28),r=Object(l.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[t._v("#")]),t._v(" 算法")]),t._v(" "),s("h2",{attrs:{id:"int-类型数-反转"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#int-类型数-反转"}},[t._v("#")]),t._v(" int 类型数 反转")]),t._v(" "),s("ul",[s("li",[t._v("问题详述:")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Input: 123\nOutput: 321\n")])])]),s("ul",[s("li",[t._v("算法思路")])]),t._v(" "),s("ol",[s("li",[t._v("将各位上的数字入栈，再出栈，出栈过程中需要判断是否溢出")]),t._v(" "),s("li",[t._v("将各位上的数字存入字符串数组，分别从头部和尾部逆向交换，得到转换后的数字，再判断是否溢出。")])]),t._v(" "),s("ul",[s("li",[t._v("注意点")])]),t._v(" "),s("ol",[s("li",[s("p",[t._v("正负数"),s("br"),t._v("\n转成正数，统一处理。")])]),t._v(" "),s("li",[s("p",[t._v("反转后的数字可能会溢出")])])]),t._v(" "),s("h2",{attrs:{id:"string-类型小数-加法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string-类型小数-加法"}},[t._v("#")]),t._v(" String 类型小数 加法")]),t._v(" "),s("ul",[s("li",[t._v("问题详述:")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Input: "123.7899" "2321.233"\nOutput: "2445.0132"\n')])])]),s("ul",[s("li",[t._v("算法思路")])]),t._v(" "),s("p",[t._v("先对输入数据做预处理，以做统一的处理。"),s("br"),t._v('\n以小数点为基准对两个输入数的整数部分和小数部分分别用0进行补齐，得到"0123.7899" "2321.2330"，'),s("br"),t._v("\n从左侧开始按位采用字符的ASCII码做加法，同时需要记录进位，最后单独处理最高位的进位。")]),t._v(" "),s("ul",[s("li",[t._v("注意点")])]),t._v(" "),s("ol",[s("li",[t._v("注意符号位")])])])}),[],!1,null,null,null);a.default=r.exports}}]);