(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{292:function(a,v,t){"use strict";t.r(v);var r=t(28),_=Object(r.a)({},(function(){var a=this,v=a.$createElement,t=a._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"java-设计思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-设计思想"}},[a._v("#")]),a._v(" Java 设计思想")]),a._v(" "),t("h2",{attrs:{id:"java中有没有虚函数？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java中有没有虚函数？"}},[a._v("#")]),a._v(" Java中有没有虚函数？")]),a._v(" "),t("p",[a._v("虚函数的作用--实现多态，指向基类的指针在操作它的多态类对象时，"),t("br"),a._v("\n会根据不同的类对象，调用其相应的函数，这个函数就是虚函数。")]),a._v(" "),t("h2",{attrs:{id:"为什么java中不支持多重继承？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么java中不支持多重继承？"}},[a._v("#")]),a._v(" 为什么Java中不支持多重继承？")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("围绕钻石形继承问题产生的歧义"),t("br"),a._v("\n考虑一个类 A 有 foo() 方法, 然后 B 和 C 派生自 A, 并且有自己的 foo() 实现，"),t("br"),a._v("\n现在 D 类使用多个继承派生自 B 和C，如果我们只引用 foo(), 编译器将无法决定它应该调用哪个 foo()。"),t("br"),a._v("\n这也称为 Diamond 问题，因为这个继承方案的结构类似于菱形。")])]),a._v(" "),t("li",[t("p",[a._v("高可维护和更清晰的设计是驱动因素")])]),a._v(" "),t("li",[t("p",[a._v("Java 可以通过使用接口支持多继承来避免这种歧义")])])]),a._v(" "),t("h2",{attrs:{id:"为什么java不支持运算符重载？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么java不支持运算符重载？"}},[a._v("#")]),a._v(" 为什么Java不支持运算符重载？")]),a._v(" "),t("p",[a._v("Java里面的String可以使用“+”进行连接的问题，藐视看起来像是重载了运算符，其实这个只是JVM做的语法糖。")]),a._v(" "),t("p",[a._v("运算符重载，将为同一运算符赋予多种含义，这将使任何开发人员的学习曲线变得陡峭，事情变得更加混乱。")]),a._v(" "),t("ol",[t("li",[a._v("简单性和清晰性")]),a._v(" "),t("li",[a._v("避免编程错误"),t("br"),a._v("\n据观察，当语言支持运算符重载时，编程错误会增加，从而增加了开发和交付时间。")]),a._v(" "),t("li",[a._v("JVM复杂性"),t("br"),a._v("\n从JVM的角度来看，支持运算符重载使问题变得更加困难。"),t("br"),a._v("\n通过更直观，更干净的方式使用方法重载也能实现同样的事情，因此不支持 Java 中的运算符重载是有意义的。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);