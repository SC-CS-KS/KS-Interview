(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{298:function(v,_,a){"use strict";a.r(_);var r=a(28),t=Object(r.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[v._v("#")]),v._v(" 对象")]),v._v(" "),a("h2",{attrs:{id:"对象的创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的创建"}},[v._v("#")]),v._v(" 对象的创建")]),v._v(" "),a("ul",[a("li",[v._v("检查")])]),v._v(" "),a("p",[v._v("虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用\n并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。\n如果没有，那必须先执行相应的类加载过程。")]),v._v(" "),a("ul",[a("li",[v._v("分配内存")])]),v._v(" "),a("p",[v._v("“指针碰撞”\n假设Java堆中内存是绝对规整的，所有用过的内存放在一遍，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，"),a("br"),v._v("\n那所分配内存就仅仅是把那个指针指向空闲空间那边挪动一段与对象大小相等的距离，这个分配方式叫做 “指针碰撞”。")]),v._v(" "),a("p",[v._v("“空闲列表”\n如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录上哪些内存块是可用的。"),a("br"),v._v("\n在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。")]),v._v(" "),a("p",[v._v("选择那种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。")]),v._v(" "),a("ul",[a("li",[a("ul",[a("li",[v._v("并发的问题")])])])]),v._v(" "),a("p",[v._v("比如在给A对象分配内存的时候，指针还没有来得及修改，对象B又同时使用了原来的指针进行了内存的分片。"),a("br"),v._v("\n两个解决方案 ：")]),v._v(" "),a("ol",[a("li",[a("p",[v._v("对分配的内存进行同步处理：CAS配上失败重试的方式 保证更新操作的原子性。")])]),v._v(" "),a("li",[a("p",[v._v("把内存分配的动作按照线程划分在不同的空间之中进行\n即每个线程在Java堆中分配一块小内存，称为本地缓冲区，哪个线程需要分配内存，就需要在本地缓冲区上进行，"),a("br"),v._v("\n只有当缓冲区用完并分配新的缓冲区的时候，才需要同步锁定。")])])]),v._v(" "),a("ul",[a("li",[v._v("init")])]),v._v(" "),a("p",[v._v("执行new指令之后会接着执行Init方法，进行初始化，这样一个对象才算产生出来。")]),v._v(" "),a("h2",{attrs:{id:"对象的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的生命周期"}},[v._v("#")]),v._v(" 对象的生命周期")]),v._v(" "),a("p",[v._v("创建阶段 、 应用阶段 、不可见阶段 、不可达阶段 、收集阶段 、终结阶段、 对象空间重新分配阶段等等。")]),v._v(" "),a("h2",{attrs:{id:"对象的内存布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局"}},[v._v("#")]),v._v(" 对象的内存布局")]),v._v(" "),a("ul",[a("li",[a("p",[v._v("对象头"),a("br"),v._v("\n储存对象自身的运行时数据，如哈希码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。"),a("br"),v._v("\n另一部分是指类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。")])]),v._v(" "),a("li",[a("p",[v._v("实例数据\n是对象正常储存的有效信息，也是程序代码中所定义的各种类型的字段内容。"),a("br"),v._v("\n无论是从父类继承下来的，还是在子类中定义的，都需要记录下来。")])]),v._v(" "),a("li",[a("p",[v._v("对齐填充\n不是必然存在的，仅仅是起到占位符的作用。\n对象的大小必须是8字节的整数倍，而对象头刚好是8字节的整数倍(1倍或者2倍)，当实例数据没有对齐的时候，就需要通过对齐填充来补全。")])])]),v._v(" "),a("h2",{attrs:{id:"对象的访问定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的访问定位"}},[v._v("#")]),v._v(" 对象的访问定位")]),v._v(" "),a("ul",[a("li",[v._v("使用句柄访问\nJava堆中将会划分出一块内存来作为句柄池，eference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址。")])]),v._v(" "),a("p",[v._v("优势："),a("br"),v._v("\nreference中存储的是稳定的句柄地址，在对象被移动（ 垃圾收集时移动对象是非常普遍的行为 ）时"),a("br"),v._v("\n只会改变句柄中的实例数据指针，而reference本身不需要修改。")]),v._v(" "),a("ul",[a("li",[v._v("使用直接指针访问")])]),v._v(" "),a("p",[v._v("Java堆对象的布局就必须考虑如何访问类型数据的相关信息，而refreence中存储的直接就是对象的地址。")]),v._v(" "),a("p",[v._v("优势："),a("br"),v._v("\n速度更快，节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。")])])}),[],!1,null,null,null);_.default=t.exports}}]);