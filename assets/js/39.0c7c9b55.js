(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{280:function(a,e,r){"use strict";r.r(e);var t=r(28),n=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"java-并发数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-并发数据结构"}},[a._v("#")]),a._v(" Java 并发数据结构")]),a._v(" "),r("h2",{attrs:{id:"threadlocal-原理？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-原理？"}},[a._v("#")]),a._v(" ThreadLocal 原理？")]),a._v(" "),r("p",[a._v("是一种以 空间换时间 的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap。"),r("br"),a._v("\n把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了。")]),a._v(" "),r("p",[a._v("ThreadLocal的设计理念与作用，是提供线程内的局部变量，在多线程环境下访问时能保证各个线程内的ThreadLocal变量各自独立。")]),a._v(" "),r("p",[a._v("最常用于以下这个场景\n多线程环境下存在对非线程安全对象的并发访问，而且该对象不需要在线程间共享。"),r("br"),a._v("\n但是我们不想加锁，这时候可以使用ThreadLocal来使得每个线程都持有一个该对象的副本。")]),a._v(" "),r("h2",{attrs:{id:"concurrenthashmap的并发度是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap的并发度是什么？"}},[a._v("#")]),a._v(" ConcurrentHashMap的并发度是什么？")]),a._v(" "),r("p",[a._v("segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap。"),r("br"),a._v("\n这也是ConcurrentHashMap对Hashtable的最大优势。")]),a._v(" "),r("h2",{attrs:{id:"blockingqueue有四个具体的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#blockingqueue有四个具体的实现"}},[a._v("#")]),a._v(" BlockingQueue有四个具体的实现")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("ArrayBlockingQueue")])]),a._v(" "),r("li",[r("p",[a._v("LinkedBlockingQueue"),r("br"),a._v("\n大小不定的BlockingQueue，\n若其构造函数带一个规定大小的参数,生成的BlockingQueue有大小限制\n若不带大小参数，所生成的BlockingQueue的大小由Integer.MAX_VALUE来决定，其所含的对象是以FIFO(先入先出)顺序排序的。")])]),a._v(" "),r("li",[r("p",[a._v("PriorityBlockingQueue")])]),a._v(" "),r("li",[r("p",[a._v("SynchronousQueue")])])]),a._v(" "),r("h2",{attrs:{id:"什么是arrayblockingqueue？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是arrayblockingqueue？"}},[a._v("#")]),a._v(" 什么是ArrayBlockingQueue？")]),a._v(" "),r("p",[a._v("一个基于数组实现的阻塞队列，它在构造时需要指定容量。"),r("br"),a._v("\n当试图向满队列中添加元素或者从空队列中移除元素时，当前线程会被阻塞。")]),a._v(" "),r("p",[a._v("通过阻塞队列，我们可以按以下模式来工作：\n工作者线程可以周期性的将中间结果放入阻塞队列中，其它线程可以取出中间结果并进行进一步操作。"),r("br"),a._v("\n若工作者线程的执行比较慢（还没来得及向队列中插入元素），其他从队列中取元素的线程会等待它（试图从空队列中取元素从而阻塞）。"),r("br"),a._v("\n若工作者线程执行较快（试图向满队列中插入元素），则它会等待其它线程取出元素再继续执行。")]),a._v(" "),r("h2",{attrs:{id:"hashtable的size-方法中明明只有一条语句-return-count-，为什么还要做同步？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hashtable的size-方法中明明只有一条语句-return-count-，为什么还要做同步？"}},[a._v("#")]),a._v(' Hashtable的size()方法中明明只有一条语句"return count"，为什么还要做同步？')])])}),[],!1,null,null,null);e.default=n.exports}}]);