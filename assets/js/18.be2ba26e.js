(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{261:function(t,r,a){"use strict";a.r(r);var v=a(28),_=Object(v.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高可用"}},[t._v("#")]),t._v(" 高可用")]),t._v(" "),a("h2",{attrs:{id:"限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[t._v("#")]),t._v(" "),a("RouterLink",{attrs:{to:"/HA/throttling/"}},[t._v("限流")])],1),t._v(" "),a("h2",{attrs:{id:"降级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#降级"}},[t._v("#")]),t._v(" 降级")]),t._v(" "),a("h2",{attrs:{id:"熔断"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#熔断"}},[t._v("#")]),t._v(" 熔断")]),t._v(" "),a("h2",{attrs:{id:"限流、降级和熔断的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#限流、降级和熔断的区别？"}},[t._v("#")]),t._v(" 限流、降级和熔断的区别？")]),t._v(" "),a("p",[t._v("限流是从系统的流量入口考虑，从进入的流量上进行限制，达到保护系统的作用。"),a("br"),t._v("\n熔断强调的是服务之间的调用能实现自我恢复的状态。"),a("br"),t._v("\n降级，是从业务的维度考虑，流量大了，可以干掉一些，保护其他正常使用。")]),t._v(" "),a("p",[t._v("服务熔断一般是下游服务故障导致的，而服务降级一般是从整体系统负荷考虑，由调用方控制。"),a("br"),t._v("\n触发原因不同，通常情况下，熔断发生的条件要更加严重，发生的概率要小。")]),t._v(" "),a("h2",{attrs:{id:"保证服务高可用的常用策略有哪些？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保证服务高可用的常用策略有哪些？"}},[t._v("#")]),t._v(" 保证服务高可用的常用策略有哪些？")]),t._v(" "),a("p",[t._v("容量评估"),a("br"),t._v("\n负载均衡"),a("br"),t._v("\n限流"),a("br"),t._v("\n排队"),a("br"),t._v("\n服务降级\n服务隔离"),a("br"),t._v("\n熔断"),a("br"),t._v("\n多数据中心"),a("br"),t._v("\n分层过滤"),a("br"),t._v("\n提前分流")]),t._v(" "),a("h2",{attrs:{id:"如何设计一个高可用系统？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何设计一个高可用系统？"}},[t._v("#")]),t._v(" 如何设计一个高可用系统？")]),t._v(" "),a("h2",{attrs:{id:"如何设计一个高并发系统？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何设计一个高并发系统？"}},[t._v("#")]),t._v(" 如何设计一个高并发系统？")]),t._v(" "),a("p",[t._v("思路：")]),t._v(" "),a("ul",[a("li",[t._v("系统拆分")]),t._v(" "),a("li",[t._v("缓存")]),t._v(" "),a("li",[t._v("MQ")]),t._v(" "),a("li",[t._v("分库分表")]),t._v(" "),a("li",[t._v("读写分离")]),t._v(" "),a("li",[t._v("ElasticSearch"),a("br"),t._v("\nES 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为可以通过扩容来扛更高的并发。"),a("br"),t._v("\n一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，"),a("br"),t._v("\n还有一些全文搜索类的操作，也可以考虑用 es 来承载。")])]),t._v(" "),a("p",[a("a",{attrs:{href:"https://doocs.github.io/advanced-java/#/./docs/high-concurrency/high-concurrency-design",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=_.exports}}]);