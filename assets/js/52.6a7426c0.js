(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{293:function(v,_,r){"use strict";r.r(_);var l=r(28),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h1",{attrs:{id:"java-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-gc"}},[v._v("#")]),v._v(" Java GC")]),v._v(" "),r("h2",{attrs:{id:"回收区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回收区域"}},[v._v("#")]),v._v(" 回收区域")]),v._v(" "),r("p",[v._v("程序计数器、虚拟机栈、本地方法栈 3个区域随线程而生 随线程而灭，"),r("br"),v._v("\n在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。")]),v._v(" "),r("p",[v._v("栈中的栈帧随着方法的进入和退出就有条不紊的执行者出栈和入栈的操作，"),r("br"),v._v("\n每一个栈分配多少个内存基本都是在类结构确定下来的时候就已经确定了。")]),v._v(" "),r("p",[v._v("这几个区域内存分配和回收都具有确定性。")]),v._v(" "),r("ul",[r("li",[v._v("堆和方法区则不同")])]),v._v(" "),r("p",[v._v("一个接口的实现是多种多样的，多个实现类需要的内存可能不一样。"),r("br"),v._v("\n一个方法中多个分支需要的内存也不一样。"),r("br"),v._v("\n我们只能在程序运行的期间知道需要创建那些对象，分配多少内存，这部分的内存分配和回收都是动态的。")]),v._v(" "),r("h2",{attrs:{id:"判断对象存活"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断对象存活"}},[v._v("#")]),v._v(" 判断对象存活")]),v._v(" "),r("ul",[r("li",[v._v("引用计数器法")])]),v._v(" "),r("p",[v._v("给对象添加一个引用计数器，任何时刻计数器为0的对象就是不可能再被使用的。")]),v._v(" "),r("ul",[r("li",[v._v("可达性分析算法")])]),v._v(" "),r("p",[v._v("通过一系列的成为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，"),r("br"),v._v("\n当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的。")]),v._v(" "),r("h2",{attrs:{id:"gc-roots的对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc-roots的对象"}},[v._v("#")]),v._v(" GC Roots的对象")]),v._v(" "),r("p",[v._v("虚拟机栈（栈帧中的本地变量表）中引用的对象。"),r("br"),v._v("\n方法区中类静态属性引用的对象。"),r("br"),v._v("\n方法区中常量引用的对象。"),r("br"),v._v("\n本地方法栈JNI（Native方法）引用的对象。")]),v._v(" "),r("h2",{attrs:{id:"java中的四种引用及其应用场景是什么？"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java中的四种引用及其应用场景是什么？"}},[v._v("#")]),v._v(" Java中的四种引用及其应用场景是什么？")]),v._v(" "),r("ul",[r("li",[r("p",[v._v("强引用"),r("br"),v._v("\n使用new操作符创建一个对象时所返回的引用即为强引用。")])]),v._v(" "),r("li",[r("p",[v._v("软引用"),r("br"),v._v("\n若一个对象只能通过软引用到达，那么这个对象在内存不足时会被回收，"),r("br"),v._v("\n可用于图片缓存中，内存不足时系统会自动回收不再使用的Bitmap。")])]),v._v(" "),r("li",[r("p",[v._v("弱引用"),r("br"),v._v("\n若一个对象只能通过弱引用到达，那么它就会被回收（即使内存充足）。")])]),v._v(" "),r("li",[r("p",[v._v("虚引用"),r("br"),v._v("\n虚引用是Java中最“弱”的引用，通过它甚至无法获取被引用的对象，它存在的唯一作用就是当它指向的对象回收时。"),r("br"),v._v("\n它本身会被加入到引用队列中，这样我们可以知道它指向的对象何时被销毁。")])])]),v._v(" "),r("h2",{attrs:{id:"finalize方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#finalize方法"}},[v._v("#")]),v._v(" Finalize方法")]),v._v(" "),r("p",[v._v("任何一个对象的finalize()方法都只会被系统自动调用一次，"),r("br"),v._v("\n如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。")]),v._v(" "),r("h2",{attrs:{id:"方法区回收"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区回收"}},[v._v("#")]),v._v(" 方法区回收")]),v._v(" "),r("p",[v._v("永久代的垃圾收集主要回收两部分内容。")]),v._v(" "),r("ul",[r("li",[v._v("废弃常量")])]),v._v(" "),r("p",[v._v('假如一个字符串“abc”已经进入了常量池中，如果当前系统没有任何一个String对象“abc”\n也就是没有任何String对象引用常量池的"abc"常量，也没有其他地方引用的这个字面量，这个时候发生内存回收这个常量就会被清理出常量池。')]),v._v(" "),r("ul",[r("li",[v._v("无用的类")])]),v._v(" "),r("p",[v._v("该类所有的实例都已经被回收，就是Java堆中不存在该类的任何实例。"),r("br"),v._v("\n加载该类的ClassLoader已经被回收。"),r("br"),v._v("\n该类对用的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。")]),v._v(" "),r("h2",{attrs:{id:"垃圾收集算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集算法"}},[v._v("#")]),v._v(" 垃圾收集算法")]),v._v(" "),r("ul",[r("li",[r("p",[v._v("标记—清除算法(mark-sweep)")])]),v._v(" "),r("li",[r("ul",[r("li",[v._v("两个阶段")])])])]),v._v(" "),r("ol",[r("li",[v._v("首先标记出所有需要回收的对象")]),v._v(" "),r("li",[v._v("在标记完成后统一回收所有被标记的对象。")])]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("不足")])])])]),v._v(" "),r("ol",[r("li",[r("p",[v._v("效率问题"),r("br"),v._v("\n标记和清除两个过程的效率都不高")])]),v._v(" "),r("li",[r("p",[v._v("空间问题"),r("br"),v._v("\n标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大的对象时，"),r("br"),v._v("\n无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。")])])]),v._v(" "),r("ul",[r("li",[v._v("复制算法(copying)")])]),v._v(" "),r("p",[v._v("将可用内存按照容量划分为大小相等的两块，每次只使用其中的一块\n就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉\n这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。")]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("不足")])])])]),v._v(" "),r("p",[v._v("将内存缩小为了原来的一半。")]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("实际")])])])]),v._v(" "),r("p",[v._v("并不需要按照1:1比例来划分内存空间。"),r("br"),v._v("\n将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。"),r("br"),v._v("\n当另一个Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。")]),v._v(" "),r("ul",[r("li",[v._v("标记整理算法(mark-compact)")])]),v._v(" "),r("p",[v._v("让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。")]),v._v(" "),r("ul",[r("li",[v._v("分代收集算法")])]),v._v(" "),r("p",[v._v("只是根据对象存活周期的不同将内存划分为几块\n一般是把java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法\n在 新生代 中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用 复制算法，只需要付出少量存活对象的复制成本就可以完成收集。\n而 老年代 中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用 标记清理 或者 标记整理 算法来进行回收。")]),v._v(" "),r("h2",{attrs:{id:"垃圾收集器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集器"}},[v._v("#")]),v._v(" 垃圾收集器")]),v._v(" "),r("ul",[r("li",[v._v("Serial 收集器")])]),v._v(" "),r("p",[v._v("单线程的收集器\n但它的单线程的意义不仅仅说明它会只使用一个CPU或一条收集线程去完成垃圾收集工作\n更重要的是它在进行垃圾收集时， 必须暂停其他所有的工作线程 ，直到它收集结束。")]),v._v(" "),r("ul",[r("li",[v._v("ParNew 收集器")])]),v._v(" "),r("p",[v._v("并行\n指多条垃圾收集线程并行工作，但此时 用户线程仍然处于等待状态。")]),v._v(" "),r("p",[v._v("并发\n指用户线程与垃圾收集线程同时执行（不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上。")]),v._v(" "),r("ul",[r("li",[v._v("Parallel Scavenge")])]),v._v(" "),r("p",[v._v("是一个新生代收集器，它是使用 复制算法的收集器 ，又是 并行的多线程收集器 。")]),v._v(" "),r("ul",[r("li",[v._v("Serial Old 收集器")])]),v._v(" "),r("p",[v._v("Serial收集器的老年代版本,是一个单线程收集器，使用 标记整理算法 。")]),v._v(" "),r("ul",[r("li",[v._v("Parallel Old 收集器")])]),v._v(" "),r("p",[v._v("Parallel Old是Paraller Seavenge收集器的老年代版本，使用 多线程和标记整理算法 。")]),v._v(" "),r("ul",[r("li",[r("p",[v._v("CMS收集器")])]),v._v(" "),r("li",[r("ul",[r("li",[v._v("CMS并非没有暂停")])])])]),v._v(" "),r("p",[v._v("而是用两次短暂停来替代串行标记整理算法的长暂停，是基于 标记清除算法 实现的")]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("收集周期")])])])]),v._v(" "),r("p",[v._v("初始标记(CMS-initial-mark) -> 并发标记(CMS-concurrent-mark) -> 重新标记(CMS-remark) ->"),r("br"),v._v("\n并发清除(CMS-concurrent-sweep) ->并发重设状态等待下次CMS的触发(CMS-concurrent-reset)")]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("4个步骤")])])])]),v._v(" "),r("p",[v._v("1.初始标记"),r("br"),v._v("\n2.并发标记"),r("br"),v._v("\n3.重新标记"),r("br"),v._v("\n4.并发清除")]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("优点")])])])]),v._v(" "),r("p",[v._v("并发收集、低停顿。")]),v._v(" "),r("ul",[r("li",[r("ul",[r("li",[v._v("缺点\nCMS收集器对CPU资源非常敏感，CMS默认启动的回收线程数是（CPU数量+3）/4。"),r("br"),v._v("\nCMS收集器无法处理浮动垃圾，可能会出现“Concurrent Mode Failure(并发模式故障)”失败而导致Full GC产生。")])])]),v._v(" "),r("li",[r("ul",[r("li",[v._v("G1")])])])]),v._v(" "),r("p",[v._v("一款面向服务器应用的垃圾收集器："),r("br"),v._v("\n并行与并发：利用多CPU缩短STOP-The-World停顿的时间\n分代收集\n空间整合：不会产生内存碎片\n可预测的停顿")]),v._v(" "),r("p",[v._v("运作方式：初始标记，并发标记，最终标记，筛选回收。")]),v._v(" "),r("h2",{attrs:{id:"内存分配引发回收的处理策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分配引发回收的处理策略"}},[v._v("#")]),v._v(" 内存分配引发回收的处理策略")]),v._v(" "),r("p",[v._v("MinorGC:清理新生代"),r("br"),v._v("\nMajorGC:清理老年代"),r("br"),v._v("\nFullGC:清理整个堆空间")]),v._v(" "),r("ul",[r("li",[v._v("对象优先在Eden分配")])]),v._v(" "),r("p",[v._v("大多数情况对象在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。")]),v._v(" "),r("ul",[r("li",[v._v("大对象直接进入老年代")])]),v._v(" "),r("p",[v._v("大对象 就是指需要大量连续内存空间的Java对象。"),r("br"),v._v("\n最典型的大对象就是那种很长的字符串以及数组。"),r("br"),v._v("\n这样做的目的是避免Eden区及两个Servivor之间发生大量的内存复制。")]),v._v(" "),r("ul",[r("li",[v._v("长期存活的对象将进入老年代")])]),v._v(" "),r("p",[v._v("如果对象在Eden区出生并且经历过一次Minor GC后仍然存活，并且能够被Servivor容纳，将被移动到Servivor空间中，并且把对象年龄设置成为1。"),r("br"),v._v("\n对象在Servivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认15岁），就将会被晋级到老年代中。")]),v._v(" "),r("ul",[r("li",[v._v("动态对象年龄判定")])]),v._v(" "),r("p",[v._v("为了更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋级到老年代\n如果在Servivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，"),r("br"),v._v("\n年龄大于或等于该年龄的对象就可以直接进入到老年代，无须登到MaxTenuringThreshold中要求的年龄。")]),v._v(" "),r("ul",[r("li",[v._v("空间分配担保")])]),v._v(" "),r("p",[v._v("在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间。"),r("br"),v._v("\n如果这个条件成立，那么Minor GC可以确保是安全的。"),r("br"),v._v("\n如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败\n如果允许那么会继续检查老年代最大可用的连续空间是否大于晋级到老年代对象的平均大小\n如果大于，将尝试进行一次Minor GC，尽管这次MinorGC 是有风险的\n如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。")])])}),[],!1,null,null,null);_.default=a.exports}}]);