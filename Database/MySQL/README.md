# MySQL

   * [MySQL](#mysql)
      * [数据常用存储方式？](#数据常用存储方式)
      * [事务有时候需要手动提交，容易忘记，Java代码使用什么方式可以实现自动提交（commit）？](#事务有时候需要手动提交容易忘记java代码使用什么方式可以实现自动提交commit)
      * [Mysql如果一个事务一直没有commit并且也没有rollback会怎样？](#mysql如果一个事务一直没有commit并且也没有rollback会怎样)
      * [索引实现原理？](#索引实现原理)
      * [文件存储要选用B 树这样的数据结构？](#文件存储要选用b树这样的数据结构)
      * [MySQL为什么选取B 树?](#mysql为什么选取b树)
      * [怎样实现有条件的索引?](#怎样实现有条件的索引)
      * [怎样在 MySQL 表中存储树形结构数据？](#怎样在-mysql-表中存储树形结构数据)

## 数据常用存储方式？   

顺序存储和链式存储    

## MySQL 主从复制原理的是什么？   

MySQL主从复制涉及到三个线程，一个运行在主节点（log dump thread），其余两个(I/O thread, SQL thread)运行在从节点。  

* 主节点 binary log dump 线程  

当从节点连接主节点时，主节点会为其创建一个log dump 线程，用于发送和读取bin-log的内容。
在读取bin-log中的操作时，log dump线程会对主节点上的bin-log加锁，当读取完成，在发送给从节点之前，锁会被释放。  
主节点会为自己的每一个从节点创建一个log dump 线程。  

* 从节点I/O线程  

用来连接主节点，请求主库中更新的bin-log。  
I/O线程接收到主节点的blog dump进程发来的更新之后，保存在本地relay-log（中继日志）中。  

* 从节点SQL线程  

负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。  

## MySQL 主从复制主要用途?

1. 主从切换 如果主库出现问题，可以快速切换到从库提供服务。  
2. 读写分离 可以在从库执行查询操作，降低主库的访问压力。  
3. 数据备份 可以在从库进行备份，以免备份期间影响主库的服务。

## MySQL 主从复制的模式有哪些？

* 异步模式  

MySQL 默认采用异步复制方式。  
主节点不会主动推送bin-log到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。  

* 半同步模式  

介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端。  
而是等待至少一个从库接收到并写到relay-log中才返回成功信息给客户端。  

相对于异步复制，半同步复制提高了数据的安全性，一定程度的保证了数据能成功备份到从库，  
同时它也造成了一定程度的延迟，半同步复制最好在低延时的网络中使用。  

* 全同步模式  

指当主库执行完一个事务，然后所有的从库都复制了该事务并成功执行完才返回成功信息给客户端。    

* GTID复制模式  

基于GTID的复制是MySQL 5.6后新增的复制方式。  
GTID (global transaction identifier) 即全局事务ID，保证了在每个在主库上提交的事务在集群中有一个唯一的ID。  

通过全局的事务ID确定从库要执行的事务的方式代替了以前需要用bin-log和pos点确定从库要执行的事务的方式。  

## MySQL 主从复制的方式有哪些？

* 基于SQL语句的复制  

只需要记录会修改数据的sql语句到bin-log中，减少了bin-log日质量，节约I/O，提高性能。  
缺点是在某些情况下，会导致主从节点中数据不一致（比如sleep(),now()等）。  

* 基于行的复制  

只记录哪条数据被修改了，修改成什么样。  
优点是不会出现某些特定情况下的存储过程、或者函数、或者trigger的调用或者触发无法被正确复制的问题。  
缺点是会产生大量的日志，尤其是修改table的时候会让日志暴增，同时增加bin-log同步时间。  
也不能通过bin-log解析获取执行过的sql语句，只能看到发生的data变更。  

* 混合模式复制  

是以上两种模式的混合，  
对于一般的复制使用STATEMENT模式保存到bin-log。  
对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式。  

对应的bin-log文件的格式也有三种：STATEMENT,  ROW,  MIXED。  

## MySQL 主从同步延时的解决方案？  

判断主从延时，通常有两个方法：  
1. Seconds_Behind_Master  
2. mk-heartbeat  Maatkit万能工具包中的一个工具，被认为可以准确判断复制延时的方法。  

造成延迟的可能因素：  
1. 网络延迟  
2. master负载  
3. slave负载  

解决方案：  

1. 使用多台slave来分摊读请求，再从这些slave中取一台专用的服务器，只作为备份用，不进行其他任何操作，  
执行relay log 里面的SQL效率自然就高了，能相对最大限度地达到'实时'的要求了。 
2. 开启MySQL的 Semi-sync（半同步），还是会存在延迟，是一种折中方案。  
3. 对于强一致场景，完全同步，但完全同步是一个非常昂贵和复杂的操作，负载量大的话几乎不可能完成。  
4. 不在主从架构上解决该问题，基于业务场景来解决  
如：分布式缓存  

## 事务有时候需要手动提交，容易忘记，Java代码使用什么方式可以实现自动提交（commit）？  

try-with-resource。  

## Mysql如果一个事务一直没有commit并且也没有rollback会怎样？  

断开链接会自动rollback，死锁或者这个锁超时的时候，也会rollback。    

## 索引实现原理？ 

* B+树  

## 文件存储要选用B+树这样的数据结构？  

* B+  tree 的磁盘读写代价更低  
内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B 树更小。  
如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。  
一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了。  

* B+ tree 的查询效率更加稳定  
由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，  
所以任何关键字的查找必须走一条从根结点到叶子结点的路，  
所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。  

## MySQL为什么选取B+树?

本质上是因为MySQL数据是存放在外部存储的  
B+树是为磁盘或其他直接存取的辅助存储设备而设计的一种数据结构。  

能够提供稳定高效的范围扫描（range-query）功能  
这也是为什么数据库和操作系统中的文件系统通常会采用b+树作为数据索引的原因  
这个特点主要因为所有叶子节点相互连接，并且叶子节点本身依关键字的大小自小而大顺序链接。  

## 怎样实现有条件的索引?

例如：  
有A、B两列，B为一个状态列取值 0 和1，要求当B = 1时，AB为唯一索引，而等于 0 时，可以任意存储。  


## 怎样在 MySQL 表中存储树形结构数据？  

1. Adjacency List：每一条记录存parent_id。  
2. Path Enumerations：每一条记录存整个tree path经过的node枚举。  
3. Nested Sets：每一条记录存 nleft 和 nright。  
4. Closure Table：维护一个表，所有的 tree path 作为记录进行保存。  

## MySQL 的查询效率影响因素？  

[链接]()  

## MySQL 性能优化思路？  

* 读写分离  
* 水平分表  
* 分库  
* 垂直分表  
* 引入Cache  

## 如何实现 MySQL 的读写分离？  

基于MySQL的主从复制机制。  

注意点：  
会存在主从复制延迟，导致数据不一致情况。  
所以对于实时性要求高的场景，是不能采用异步主从复制来实现读写分离的。    

* 基于程序代码内部实现   

在代码中根据select,insert进行路由分类。  

* 基于中间代理层实现  

## 如何解决MySQL主库宕机导致的数据丢失情况？  

一般是 MySQL 异步复制导致，可以采用半同步复制模式。  

